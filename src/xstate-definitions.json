[
  {
    "fileName": "Actor.d.ts",
    "content": "import { EventObject, Subscribable } from './types';\nexport interface Actor<TContext = any, TEvent extends EventObject = EventObject> extends Subscribable<TContext> {\n    id: string;\n    send: (event: TEvent) => any;\n    stop?: () => any | undefined;\n    toJSON: () => {\n        id: string;\n    };\n}\nexport declare function isActor(item: any): item is Actor;\n"
  },
  {
    "fileName": "Machine.d.ts",
    "content": "import { StateMachine, MachineOptions, DefaultContext, MachineConfig, StateSchema, EventObject } from './types';\nexport declare function Machine<TContext = DefaultContext, TStateSchema extends StateSchema = any, TEvent extends EventObject = EventObject>(config: MachineConfig<TContext, TStateSchema, TEvent>, options?: Partial<MachineOptions<TContext, TEvent>>, initialContext?: TContext | undefined): StateMachine<TContext, TStateSchema, TEvent>;\n"
  },
  {
    "fileName": "SimulatedClock.d.ts",
    "content": "import { Clock } from './interpreter';\nexport interface SimulatedClock extends Clock {\n    start(speed: number): void;\n    increment(ms: number): void;\n    set(ms: number): void;\n}\nexport declare class SimulatedClock implements SimulatedClock {\n    private timeouts;\n    private _now;\n    private _id;\n    now(): number;\n    private getId;\n    setTimeout(fn: (...args: any[]) => void, timeout: number): number;\n    clearTimeout(id: number): void;\n    private flushTimeouts;\n}\n"
  },
  {
    "fileName": "State.d.ts",
    "content": "import { StateValue, ActivityMap, EventObject, StateInterface, HistoryValue, ActionObject, EventType, StateConfig, OmniEventObject } from './types';\nimport { StateTree } from './StateTree';\nexport declare function stateValuesEqual(a: StateValue | undefined, b: StateValue | undefined): boolean;\nexport declare class State<TContext, TEvent extends EventObject = EventObject> implements StateInterface<TContext> {\n    value: StateValue;\n    context: TContext;\n    historyValue?: HistoryValue | undefined;\n    history?: State<TContext>;\n    actions: Array<ActionObject<TContext, TEvent>>;\n    activities: ActivityMap;\n    meta: any;\n    events: TEvent[];\n    event: OmniEventObject<TEvent>;\n    /**\n     * Indicates whether the state has changed from the previous state. A state is considered \"changed\" if:\n     *\n     * - Its value is not equal to its previous value, or:\n     * - It has any new actions (side-effects) to execute.\n     *\n     * An initial state (with no history) will return `undefined`.\n     */\n    changed: boolean | undefined;\n    /**\n     * The state node tree representation of the state value.\n     */\n    tree?: StateTree;\n    /**\n     * Creates a new State instance for the given `stateValue` and `context`.\n     * @param stateValue\n     * @param context\n     */\n    static from<TC, TE extends EventObject = EventObject>(stateValue: State<TC, TE> | StateValue, context?: TC | undefined): State<TC, TE>;\n    /**\n     * Creates a new State instance for the given `config`.\n     * @param config The state config\n     */\n    static create<TC, TE extends EventObject = EventObject>(config: StateConfig<TC, TE>): State<TC, TE>;\n    /**\n     * Creates a new `State` instance for the given `stateValue` and `context` with no actions (side-effects).\n     * @param stateValue\n     * @param context\n     */\n    static inert<TC, TE extends EventObject = EventObject>(stateValue: State<TC> | StateValue, context: TC): State<TC, TE>;\n    /**\n     * Returns a new `State` instance that is equal to this state no actions (side-effects).\n     */\n    readonly inert: State<TContext, TEvent>;\n    /**\n     * Creates a new State instance.\n     * @param value The state value\n     * @param context The extended state\n     * @param historyValue The tree representing historical values of the state nodes\n     * @param history The previous state\n     * @param actions An array of action objects to execute as side-effects\n     * @param activities A mapping of activities and whether they are started (`true`) or stopped (`false`).\n     * @param meta\n     * @param events Internal event queue. Should be empty with run-to-completion semantics.\n     * @param tree\n     */\n    constructor(config: StateConfig<TContext, TEvent>);\n    /**\n     * The next events that will cause a transition from the current state.\n     */\n    readonly nextEvents: EventType[];\n    /**\n     * Returns an array of all the string leaf state node paths.\n     * @param stateValue\n     * @param delimiter The character(s) that separate each subpath in the string state node path.\n     */\n    toStrings(stateValue?: StateValue, delimiter?: string): string[];\n    /**\n     * Whether the current state value is a subset of the given parent state value.\n     * @param parentStateValue\n     */\n    matches(parentStateValue: StateValue): boolean;\n}\n"
  },
  {
    "fileName": "StateNode.d.ts",
    "content": "import { Event, StateValue, MachineOptions, EventObject, HistoryValue, StateNodeDefinition, TransitionDefinition, DelayedTransitionDefinition, ActivityDefinition, StateTypes, StateNodeConfig, StateSchema, TransitionsDefinition, StateNodesConfig, OmniEventObject, InvokeDefinition, OmniEvent, ActionObject, Mapper, PropertyMapper } from './types';\nimport { State } from './State';\ndeclare class StateNode<TContext = any, TStateSchema extends StateSchema = any, TEvent extends OmniEventObject<EventObject> = OmniEventObject<EventObject>> {\n    /**\n     * The initial extended state\n     */\n    context?: Readonly<TContext> | undefined;\n    /**\n     * The relative key of the state node, which represents its location in the overall state value.\n     */\n    key: string;\n    /**\n     * The unique ID of the state node.\n     */\n    id: string;\n    /**\n     * The machine's own version.\n     */\n    version?: string;\n    /**\n     * The type of this state node:\n     *\n     *  - `'atomic'` - no child state nodes\n     *  - `'compound'` - nested child state nodes (XOR)\n     *  - `'parallel'` - orthogonal nested child state nodes (AND)\n     *  - `'history'` - history state node\n     *  - `'final'` - final state node\n     */\n    type: StateTypes;\n    /**\n     * The string path from the root machine node to this node.\n     */\n    path: string[];\n    /**\n     * The initial state node key.\n     */\n    initial?: keyof TStateSchema['states'];\n    /**\n     * (DEPRECATED) Whether the state node is a parallel state node.\n     *\n     * Use `type: 'parallel'` instead.\n     */\n    parallel?: boolean;\n    /**\n     * Whether the state node is \"transient\". A state node is considered transient if it has\n     * an immediate transition from a \"null event\" (empty string), taken upon entering the state node.\n     */\n    private _transient;\n    /**\n     * The child state nodes.\n     */\n    states: StateNodesConfig<TContext, TStateSchema, TEvent>;\n    /**\n     * The type of history exhibited. Can be:\n     *\n     *  - `'shallow'` - recalls only top-level historical state value\n     *  - `'deep'` - recalls historical state value at all levels\n     */\n    history: false | 'shallow' | 'deep';\n    /**\n     * The action(s) to be executed upon entering the state node.\n     */\n    onEntry: Array<ActionObject<TContext, TEvent>>;\n    /**\n     * The action(s) to be executed upon exiting the state node.\n     */\n    onExit: Array<ActionObject<TContext, TEvent>>;\n    /**\n     * The activities to be started upon entering the state node,\n     * and stopped upon exiting the state node.\n     */\n    activities: Array<ActivityDefinition<TContext, TEvent>>;\n    /**\n     * The delayed transitions.\n     */\n    after: Array<DelayedTransitionDefinition<TContext, TEvent>>;\n    strict: boolean;\n    /**\n     * The parent state node.\n     */\n    parent?: StateNode<TContext, any, TEvent>;\n    /**\n     * The root machine node.\n     */\n    machine: StateNode<TContext, any, TEvent>;\n    /**\n     * The meta data associated with this state node, which will be returned in State instances.\n     */\n    meta?: TStateSchema extends {\n        meta: infer D;\n    } ? D : any;\n    /**\n     * The data sent with the \"done.state._id_\" event if this is a final state node.\n     */\n    data?: Mapper<TContext, TEvent> | PropertyMapper<TContext, TEvent>;\n    /**\n     * The string delimiter for serializing the path to a string. The default is \".\"\n     */\n    delimiter: string;\n    /**\n     * The order this state node appears. Corresponds to the implicit SCXML document order.\n     */\n    order: number;\n    /**\n     * The services invoked by this state node.\n     */\n    invoke: Array<InvokeDefinition<TContext, TEvent>>;\n    options: MachineOptions<TContext, TEvent>;\n    /**\n     * The raw config used to create the machine.\n     */\n    config: StateNodeConfig<TContext, TStateSchema, TEvent>;\n    __xstatenode: true;\n    private __cache;\n    private idMap;\n    constructor(_config: StateNodeConfig<TContext, TStateSchema, TEvent>, options?: Partial<MachineOptions<TContext, TEvent>>, \n    /**\n     * The initial extended state\n     */\n    context?: Readonly<TContext> | undefined);\n    /**\n     * Clones this state machine with custom options and context.\n     *\n     * @param options Options (actions, guards, activities, services) to recursively merge with the existing options.\n     * @param context Custom context (will override predefined context)\n     */\n    withConfig(options: Partial<MachineOptions<TContext, TEvent>>, context?: TContext | undefined): StateNode<TContext, TStateSchema, TEvent>;\n    /**\n     * Clones this state machine with custom context.\n     *\n     * @param context Custom context (will override predefined context, not recursive)\n     */\n    withContext(context: TContext): StateNode<TContext, TStateSchema, TEvent>;\n    /**\n     * The well-structured state node definition.\n     */\n    readonly definition: StateNodeDefinition<TContext, TStateSchema, TEvent>;\n    toJSON(): StateNodeDefinition<TContext, TStateSchema, TEvent>;\n    /**\n     * The mapping of events to transitions.\n     */\n    readonly on: TransitionsDefinition<TContext, TEvent>;\n    /**\n     * All the transitions that can be taken from this state node.\n     */\n    readonly transitions: Array<TransitionDefinition<TContext, TEvent>>;\n    /**\n     * All delayed transitions from the config.\n     */\n    private getDelayedTransitions;\n    /**\n     * Returns the state nodes represented by the current state value.\n     *\n     * @param state The state value or State instance\n     */\n    getStateNodes(state: StateValue | State<TContext, TEvent>): Array<StateNode<TContext, any, TEvent>>;\n    /**\n     * Returns `true` if this state node explicitly handles the given event.\n     *\n     * @param event The event in question\n     */\n    handles(event: Event<TEvent>): boolean;\n    /**\n     * Resolves the given `state` to a new `State` instance relative to this machine.\n     *\n     * This ensures that `.events` and `.nextEvents` represent the correct values.\n     *\n     * @param state The state to resolve\n     */\n    resolveState(state: State<TContext, TEvent>): State<TContext, TEvent>;\n    private transitionLeafNode;\n    private transitionCompoundNode;\n    private transitionParallelNode;\n    private _transition;\n    private next;\n    /**\n     * The state tree represented by this state node.\n     */\n    private readonly tree;\n    private nodesFromChild;\n    private getStateTree;\n    /**\n     * Whether the given state node \"escapes\" this state node. If the `stateNode` is equal to or the parent of\n     * this state node, it does not escape.\n     */\n    private escapes;\n    private evaluateGuard;\n    private getActions;\n    /**\n     * Determines the next state given the current `state` and sent `event`.\n     *\n     * @param state The current State instance or state value\n     * @param event The event that was sent at the current state\n     * @param context The current context (extended state) of the current state\n     */\n    transition(state: StateValue | State<TContext, TEvent>, event: OmniEvent<TEvent>, context?: TContext): State<TContext, TEvent>;\n    private resolveTransition;\n    private ensureValidPaths;\n    /**\n     * Returns the child state node from its relative `stateKey`, or throws.\n     */\n    getStateNode(stateKey: string): StateNode<TContext, any, TEvent>;\n    /**\n     * Returns the state node with the given `stateId`, or throws.\n     *\n     * @param stateId The state ID. The prefix \"#\" is removed.\n     */\n    getStateNodeById(stateId: string): StateNode<TContext, any, TEvent>;\n    /**\n     * Returns the relative state node from the given `statePath`, or throws.\n     *\n     * @param statePath The string or string array relative path to the state node.\n     */\n    getStateNodeByPath(statePath: string | string[]): StateNode<TContext, any, TEvent>;\n    /**\n     * Resolves a partial state value with its full representation in this machine.\n     *\n     * @param stateValue The partial state value to resolve.\n     */\n    resolve(stateValue: StateValue): StateValue;\n    private readonly resolvedStateValue;\n    private getResolvedPath;\n    private readonly initialStateValue;\n    getInitialState(stateValue: StateValue, context?: TContext): State<TContext, TEvent>;\n    /**\n     * The initial State instance, which includes all actions to be executed from\n     * entering the initial state.\n     */\n    readonly initialState: State<TContext, TEvent>;\n    /**\n     * The target state value of the history state node, if it exists. This represents the\n     * default state value to transition to if no history value exists yet.\n     */\n    readonly target: StateValue | undefined;\n    getStates(stateValue: StateValue): Array<StateNode<TContext>>;\n    /**\n     * Returns the leaf nodes from a state path relative to this state node.\n     *\n     * @param relativeStateId The relative state path to retrieve the state nodes\n     * @param history The previous state to retrieve history\n     * @param resolve Whether state nodes should resolve to initial child state nodes\n     */\n    getRelativeStateNodes(relativeStateId: string | string[], historyValue?: HistoryValue, resolve?: boolean): Array<StateNode<TContext, any, TEvent>>;\n    readonly initialStateNodes: Array<StateNode<TContext, any, TEvent>>;\n    /**\n     * Retrieves state nodes from a relative path to this state node.\n     *\n     * @param relativePath The relative path from this state node\n     * @param historyValue\n     */\n    getFromRelativePath(relativePath: string[], historyValue?: HistoryValue): Array<StateNode<TContext, any, TEvent>>;\n    private historyValue;\n    /**\n     * Resolves to the historical value(s) of the parent state node,\n     * represented by state nodes.\n     *\n     * @param historyValue\n     */\n    private resolveHistory;\n    /**\n     * All the state node IDs of this state node and its descendant state nodes.\n     */\n    readonly stateIds: string[];\n    /**\n     * All the event types accepted by this state node and its descendants.\n     */\n    readonly events: Array<TEvent['type']>;\n    /**\n     * All the events that have transitions directly from this state node.\n     *\n     * Excludes any inert events.\n     */\n    readonly ownEvents: Array<TEvent['type']>;\n    private formatTransition;\n    private formatTransitions;\n}\nexport { StateNode };\n"
  },
  {
    "fileName": "StateTree.d.ts",
    "content": "import { StateNode } from './StateNode';\nimport { StateValue, EntryExitStateArrays, EventType, EventObject } from './types';\nexport interface StateTreeOptions {\n    resolved?: boolean;\n}\nexport declare class StateTree {\n    stateNode: StateNode;\n    stateValue: StateValue | undefined;\n    parent?: StateTree | undefined;\n    root: StateTree;\n    nodes: Record<string, StateTree>;\n    isResolved: boolean;\n    private reentryNodes;\n    constructor(stateNode: StateNode, stateValue: StateValue | undefined, options?: StateTreeOptions, parent?: StateTree | undefined);\n    readonly done: boolean;\n    getDoneData<TContext>(context: TContext, event: EventObject): any;\n    readonly atomicNodes: StateNode[];\n    getDoneEvents(entryStateNodes?: Set<StateNode>): EventObject[];\n    readonly resolved: StateTree;\n    readonly paths: string[][];\n    readonly absolute: StateTree;\n    readonly nextEvents: EventType[];\n    clone(): StateTree;\n    combine(tree: StateTree): StateTree;\n    readonly value: StateValue;\n    matches(parentValue: StateValue): boolean;\n    getEntryExitStates(prevTree?: StateTree): EntryExitStateArrays<any>;\n    getEntryStates(): StateNode[];\n    getExitStates(): StateNode[];\n    addReentryNode(reentryNode: StateNode): void;\n}\n"
  },
  {
    "fileName": "actionTypes.d.ts",
    "content": "import { ActionTypes } from './types';\nexport declare const start = ActionTypes.Start;\nexport declare const stop = ActionTypes.Stop;\nexport declare const raise = ActionTypes.Raise;\nexport declare const send = ActionTypes.Send;\nexport declare const cancel = ActionTypes.Cancel;\nexport declare const nullEvent = ActionTypes.NullEvent;\nexport declare const assign = ActionTypes.Assign;\nexport declare const after = ActionTypes.After;\nexport declare const doneState = ActionTypes.DoneState;\nexport declare const log = ActionTypes.Log;\nexport declare const init = ActionTypes.Init;\nexport declare const invoke = ActionTypes.Invoke;\nexport declare const errorExecution = ActionTypes.ErrorExecution;\nexport declare const errorPlatform = ActionTypes.ErrorPlatform;\nexport declare const update = ActionTypes.Update;\n"
  },
  {
    "fileName": "actions.d.ts",
    "content": "import { Action, Event, EventObject, SingleOrArray, SendAction, SendActionOptions, CancelAction, ActionObject, ActionType, Assigner, AssignAction, ActionFunction, ActionFunctionMap, ActivityActionObject, ActionTypes, ActivityDefinition, RaiseEvent, DoneEvent, ErrorPlatformEvent, DoneEventObject, SendExpr, SendActionObject, OmniEventObject, PureAction } from './types';\nimport * as actionTypes from './actionTypes';\nexport { actionTypes };\nexport declare const initEvent: {\n    type: ActionTypes.Init;\n};\nexport declare function toEventObject<TEvent extends EventObject>(event: Event<TEvent>, payload?: Record<string, any> & {\n    type?: never;\n}): TEvent;\nexport declare function getActionFunction<TContext, TEvent extends EventObject>(actionType: ActionType, actionFunctionMap?: ActionFunctionMap<TContext, TEvent>): ActionObject<TContext, TEvent> | ActionFunction<TContext, TEvent> | undefined;\nexport declare function toActionObject<TContext, TEvent extends EventObject>(action: Action<TContext, TEvent>, actionFunctionMap?: ActionFunctionMap<TContext, TEvent>): ActionObject<TContext, TEvent>;\nexport declare const toActionObjects: <TContext, TEvent extends EventObject>(action?: string | ActionObject<TContext, TEvent> | ActionFunction<TContext, TEvent> | Action<TContext, TEvent>[] | undefined, actionFunctionMap?: Record<string, ActionObject<TContext, TEvent> | ActionFunction<TContext, TEvent>> | undefined) => ActionObject<TContext, TEvent>[];\nexport declare function toActivityDefinition<TContext, TEvent extends EventObject>(action: string | ActivityDefinition<TContext, TEvent>): ActivityDefinition<TContext, TEvent>;\n/**\n * Raises an event. This places the event in the internal event queue, so that\n * the event is immediately consumed by the machine in the current step.\n *\n * @param eventType The event to raise.\n */\nexport declare function raise<TContext, TEvent extends EventObject>(event: Event<TEvent>): RaiseEvent<TContext, TEvent>;\n/**\n * Sends an event. This returns an action that will be read by an interpreter to\n * send the event in the next step, after the current step is finished executing.\n *\n * @param event The event to send.\n * @param options Options to pass into the send event:\n *  - `id` - The unique send event identifier (used with `cancel()`).\n *  - `delay` - The number of milliseconds to delay the sending of the event.\n *  - `target` - The target of this event (by default, the machine the event was sent from).\n */\nexport declare function send<TContext, TEvent extends EventObject>(event: Event<TEvent> | SendExpr<TContext, TEvent>, options?: SendActionOptions<TContext, TEvent>): SendAction<TContext, TEvent>;\nexport declare function resolveSend<TContext, TEvent extends EventObject>(action: SendAction<TContext, TEvent>, ctx: TContext, event: TEvent): SendActionObject<TContext, OmniEventObject<TEvent>>;\n/**\n * Sends an event to this machine's parent machine.\n *\n * @param event The event to send to the parent machine.\n * @param options Options to pass into the send event.\n */\nexport declare function sendParent<TContext, TEvent extends EventObject>(event: Event<TEvent> | SendExpr<TContext, TEvent>, options?: SendActionOptions<TContext, TEvent>): SendAction<TContext, TEvent>;\n/**\n *\n * @param expr The expression function to evaluate which will be logged.\n *  Takes in 2 arguments:\n *  - `ctx` - the current state context\n *  - `event` - the event that caused this action to be executed.\n * @param label The label to give to the logged expression.\n */\nexport declare function log<TContext, TEvent extends EventObject>(expr?: (ctx: TContext, event: TEvent) => any, label?: string): {\n    type: ActionTypes;\n    label: string | undefined;\n    expr: (ctx: TContext, event: TEvent) => any;\n};\n/**\n * Cancels an in-flight `send(...)` action. A canceled sent action will not\n * be executed, nor will its event be sent, unless it has already been sent\n * (e.g., if `cancel(...)` is called after the `send(...)` action's `delay`).\n *\n * @param sendId The `id` of the `send(...)` action to cancel.\n */\nexport declare const cancel: (sendId: string | number) => CancelAction;\n/**\n * Starts an activity.\n *\n * @param activity The activity to start.\n */\nexport declare function start<TContext, TEvent extends EventObject>(activity: string | ActivityDefinition<TContext, TEvent>): ActivityActionObject<TContext, TEvent>;\n/**\n * Stops an activity.\n *\n * @param activity The activity to stop.\n */\nexport declare function stop<TContext, TEvent extends EventObject>(activity: string | ActivityDefinition<TContext, TEvent>): ActivityActionObject<TContext, TEvent>;\n/**\n * Updates the current context of the machine.\n *\n * @param assignment An object that represents the partial context to update.\n */\nexport declare const assign: <TContext, TEvent extends EventObject = EventObject>(assignment: Assigner<TContext, TEvent> | Partial<{ [K in keyof TContext]: ((context: TContext, event: TEvent) => TContext[K]) | TContext[K]; }>) => AssignAction<TContext, TEvent>;\nexport declare function isActionObject<TContext, TEvent extends EventObject>(action: Action<TContext, TEvent>): action is ActionObject<TContext, TEvent>;\n/**\n * Returns an event type that represents an implicit event that\n * is sent after the specified `delay`.\n *\n * @param delayRef The delay in milliseconds\n * @param id The state node ID where this event is handled\n */\nexport declare function after(delayRef: number | string, id?: string): string;\n/**\n * Returns an event that represents that a final state node\n * has been reached in the parent state node.\n *\n * @param id The final state node's parent state node `id`\n * @param data The data to pass into the event\n */\nexport declare function done(id: string, data?: any): DoneEventObject;\n/**\n * Returns an event that represents that an invoked service has terminated.\n *\n * An invoked service is terminated when it has reached a top-level final state node,\n * but not when it is canceled.\n *\n * @param id The final state node ID\n * @param data The data to pass into the event\n */\nexport declare function doneInvoke(id: string, data?: any): DoneEvent;\nexport declare function error(id: string, data?: any): (ErrorPlatformEvent & string);\nexport declare function pure<TContext, TEvent extends EventObject>(getActions: ((context: TContext, event: OmniEventObject<TEvent>) => SingleOrArray<ActionObject<TContext, TEvent>> | undefined)): PureAction<TContext, TEvent>;\n"
  },
  {
    "fileName": "constants.d.ts",
    "content": "import { ActivityMap, DefaultGuardType } from './types';\nexport declare const STATE_DELIMITER = \".\";\nexport declare const EMPTY_ACTIVITY_MAP: ActivityMap;\nexport declare const DEFAULT_GUARD_TYPE: DefaultGuardType;\n"
  },
  {
    "fileName": "each.d.ts",
    "content": "import { EventObject, SingleOrArray, ActionObject } from '.';\nexport declare function each<TContext, TEvent extends EventObject>(collection: keyof TContext, item: keyof TContext, actions: SingleOrArray<ActionObject<TContext, TEvent>>): ActionObject<TContext, TEvent>;\nexport declare function each<TContext, TEvent extends EventObject>(collection: keyof TContext, item: keyof TContext, index: keyof TContext, actions: SingleOrArray<ActionObject<TContext, TEvent>>): ActionObject<TContext, TEvent>;\n"
  },
  {
    "fileName": "environment.d.ts",
    "content": "export declare const IS_PRODUCTION: boolean;\n"
  },
  {
    "fileName": "graph.d.ts",
    "content": "import { StateNode, State } from './';\nimport { StateValue, Edge, PathMap, PathsItem, PathsMap, AdjacencyMap, DefaultContext, ValueAdjacencyMap, EventObject, StateMachine } from './types';\nexport declare function getNodes(node: StateNode): StateNode[];\nexport declare function getEventEdges<TContext = DefaultContext, TEvent extends EventObject = EventObject>(node: StateNode<TContext, any, TEvent>, event: string): Array<Edge<TContext, TEvent>>;\nexport declare function getEdges<TContext = DefaultContext, TEvent extends EventObject = EventObject>(node: StateNode<TContext, any, TEvent>, options?: {\n    depth: null | number;\n}): Array<Edge<TContext, TEvent>>;\nexport declare function adjacencyMap<TContext = DefaultContext>(node: StateNode<TContext>, context?: TContext): AdjacencyMap;\nexport declare function deserializeStateString(valueContextString: string): {\n    value: StateValue;\n    context: any;\n};\nexport declare function serializeState<TContext>(state: State<TContext>): string;\nexport declare function serializeEvent<TEvent extends EventObject>(event: TEvent): string;\nexport declare function deserializeEventString<TEvent extends EventObject>(eventString: string): TEvent;\nexport interface ValueAdjMapOptions<TContext, TEvent extends EventObject> {\n    events: {\n        [K in TEvent['type']]: Array<TEvent & {\n            type: K;\n        }>;\n    };\n    filter: (state: State<TContext>) => boolean;\n    formatContext: <T>(context: TContext) => T;\n    stateSerializer: (state: State<TContext>) => string;\n    eventSerializer: (event: TEvent) => string;\n}\nexport declare function getValueAdjacencyMap<TContext = DefaultContext, TEvent extends EventObject = EventObject>(node: StateNode<TContext, any, TEvent>, options?: Partial<ValueAdjMapOptions<TContext, TEvent>>): ValueAdjacencyMap<TContext, TEvent>;\nexport declare function getShortestPaths<TContext = DefaultContext, TEvent extends EventObject = EventObject>(machine: StateMachine<TContext, any, TEvent>, options?: Partial<ValueAdjMapOptions<TContext, TEvent>>): PathMap<TContext, TEvent>;\nexport declare function getSimplePaths<TContext = DefaultContext, TEvent extends EventObject = EventObject>(machine: StateMachine<TContext, any, TEvent>, options?: Partial<ValueAdjMapOptions<TContext, TEvent>>): PathsMap<TContext, TEvent>;\nexport declare function getSimplePathsAsArray<TContext = DefaultContext, TEvent extends EventObject = EventObject>(machine: StateNode<TContext, any, TEvent>, options?: ValueAdjMapOptions<TContext, TEvent>): Array<PathsItem<TContext, TEvent>>;\n"
  },
  {
    "fileName": "index.d.ts",
    "content": "import { matchesState } from './utils';\nimport { mapState } from './mapState';\nimport { StateNode } from './StateNode';\nimport { State } from './State';\nimport { Machine } from './Machine';\nimport { raise, send, sendParent, log, start, stop, assign, after, done } from './actions';\nimport { interpret, Interpreter, spawn } from './interpreter';\nimport { matchState } from './match';\ndeclare const actions: {\n    raise: typeof raise;\n    send: typeof send;\n    sendParent: typeof sendParent;\n    log: typeof log;\n    cancel: (sendId: string | number) => import(\"./types\").CancelAction;\n    start: typeof start;\n    stop: typeof stop;\n    assign: <TContext, TEvent extends import(\"./types\").EventObject = import(\"./types\").EventObject>(assignment: import(\"./types\").Assigner<TContext, TEvent> | Partial<{ [K in keyof TContext]: ((context: TContext, event: TEvent) => TContext[K]) | TContext[K]; }>) => import(\"./types\").AssignAction<TContext, TEvent>;\n    after: typeof after;\n    done: typeof done;\n};\nexport { Machine, StateNode, State, matchesState, mapState, actions, assign, send, sendParent, interpret, Interpreter, matchState, spawn };\nexport * from './types';\n"
  },
  {
    "fileName": "interpreter.d.ts",
    "content": "import { StateMachine, Event, EventObject, DefaultContext, StateSchema, OmniEventObject, OmniEvent, InvokeCallback, StateValue, InterpreterOptions, SingleOrArray, Subscribable, DoneEvent, Unsubscribable, MachineOptions } from './types';\nimport { State } from './State';\nimport { Actor } from './Actor';\nexport declare type StateListener<TContext, TEvent extends EventObject> = (state: State<TContext, TEvent>, event: OmniEventObject<TEvent>) => void;\nexport declare type ContextListener<TContext = DefaultContext> = (context: TContext, prevContext: TContext | undefined) => void;\nexport declare type EventListener<TEvent extends EventObject = EventObject> = (event: TEvent) => void;\nexport declare type Listener = () => void;\nexport interface Clock {\n    setTimeout(fn: (...args: any[]) => void, timeout: number): any;\n    clearTimeout(id: any): void;\n}\ninterface SpawnOptions {\n    name?: string;\n    autoForward?: boolean;\n    sync?: boolean;\n}\nexport declare class Interpreter<TContext, TStateSchema extends StateSchema = any, TEvent extends EventObject = EventObject> implements Subscribable<State<TContext, TEvent>>, Actor<State<TContext, TEvent>, OmniEventObject<TEvent>> {\n    machine: StateMachine<TContext, TStateSchema, TEvent>;\n    /**\n     * The default interpreter options:\n     *\n     * - `clock` uses the global `setTimeout` and `clearTimeout` functions\n     * - `logger` uses the global `console.log()` method\n     */\n    static defaultOptions: InterpreterOptions;\n    /**\n     * The current state of the interpreted machine.\n     */\n    state: State<TContext, TEvent>;\n    /**\n     * The clock that is responsible for setting and clearing timeouts, such as delayed events and transitions.\n     */\n    clock: Clock;\n    options: Readonly<InterpreterOptions>;\n    private scheduler;\n    private delayedEventsMap;\n    private listeners;\n    private contextListeners;\n    private stopListeners;\n    private doneListeners;\n    private eventListeners;\n    private sendListeners;\n    private logger;\n    /**\n     * Whether the service is started.\n     */\n    initialized: boolean;\n    /**\n     * The initial state of the machine.\n     */\n    initialState: State<TContext, TEvent>;\n    parent?: Interpreter<any>;\n    id: string;\n    children: Map<string | number, Actor>;\n    private forwardTo;\n    private devTools?;\n    /**\n     * Creates a new Interpreter instance (i.e., service) for the given machine with the provided options, if any.\n     *\n     * @param machine The machine to be interpreted\n     * @param options Interpreter options\n     */\n    constructor(machine: StateMachine<TContext, TStateSchema, TEvent>, options?: Partial<InterpreterOptions>);\n    static interpret: typeof interpret;\n    /**\n     * Executes the actions of the given state, with that state's `context` and `event`.\n     *\n     * @param state The state whose actions will be executed\n     * @param actionsConfig The action implementations to use\n     */\n    execute(state: State<TContext, TEvent>, actionsConfig?: MachineOptions<TContext, TEvent>['actions']): void;\n    private update;\n    onTransition(listener: StateListener<TContext, TEvent>): Interpreter<TContext, TStateSchema, TEvent>;\n    subscribe(nextListener?: (state: State<TContext, TEvent>) => void, errorListener?: (error: any) => void, completeListener?: () => void): Unsubscribable;\n    /**\n     * Adds an event listener that is notified whenever an event is sent to the running interpreter.\n     * @param listener The event listener\n     */\n    onEvent(listener: EventListener): Interpreter<TContext, TStateSchema, TEvent>;\n    /**\n     * Adds an event listener that is notified whenever a `send` event occurs.\n     * @param listener The event listener\n     */\n    onSend(listener: EventListener): Interpreter<TContext, TStateSchema, TEvent>;\n    /**\n     * Adds a context listener that is notified whenever the state context changes.\n     * @param listener The context listener\n     */\n    onChange(listener: ContextListener<TContext>): Interpreter<TContext, TStateSchema, TEvent>;\n    /**\n     * Adds a listener that is notified when the machine is stopped.\n     * @param listener The listener\n     */\n    onStop(listener: Listener): Interpreter<TContext, TStateSchema, TEvent>;\n    /**\n     * Adds a state listener that is notified when the statechart has reached its final state.\n     * @param listener The state listener\n     */\n    onDone(listener: EventListener<DoneEvent>): Interpreter<TContext, TStateSchema, TEvent>;\n    /**\n     * Removes a listener.\n     * @param listener The listener to remove\n     */\n    off(listener: (...args: any[]) => void): Interpreter<TContext, TStateSchema, TEvent>;\n    /**\n     * Alias for Interpreter.prototype.start\n     */\n    init: (initialState?: string | import(\"./types\").StateValueMap | State<TContext, TEvent> | undefined) => Interpreter<TContext, TStateSchema, TEvent>;\n    /**\n     * Starts the interpreter from the given state, or the initial state.\n     * @param initialState The state to start the statechart from\n     */\n    start(initialState?: State<TContext, TEvent> | StateValue): Interpreter<TContext, TStateSchema, TEvent>;\n    /**\n     * Stops the interpreter and unsubscribe all listeners.\n     *\n     * This will also notify the `onStop` listeners.\n     */\n    stop(): Interpreter<TContext, TStateSchema, TEvent>;\n    /**\n     * Sends an event to the running interpreter to trigger a transition.\n     *\n     * An array of events (batched) can be sent as well, which will send all\n     * batched events to the running interpreter. The listeners will be\n     * notified only **once** when all events are processed.\n     *\n     * @param event The event(s) to send\n     */\n    send: (event: SingleOrArray<OmniEvent<TEvent>>, payload?: (Record<string, any> & {\n        type?: undefined;\n    }) | undefined) => State<TContext, TEvent>;\n    private batch;\n    /**\n     * Returns a send function bound to this interpreter instance.\n     *\n     * @param event The event to be sent by the sender.\n     */\n    sender(event: Event<TEvent>): () => State<TContext, TEvent>;\n    sendTo: (event: OmniEventObject<TEvent>, to: string | number | Actor<any, EventObject>) => void;\n    /**\n     * Returns the next state given the interpreter's current state and the event.\n     *\n     * This is a pure method that does _not_ update the interpreter's state.\n     *\n     * @param event The event to determine the next state\n     */\n    nextState(event: OmniEvent<TEvent>): State<TContext, TEvent>;\n    private forward;\n    private defer;\n    private cancel;\n    private exec;\n    private stopChild;\n    spawn<TChildContext>(entity: Spawnable<TChildContext>, name: string, options?: SpawnOptions): Actor;\n    spawnMachine<TChildContext, TChildStateSchema, TChildEvents extends EventObject>(machine: StateMachine<TChildContext, TChildStateSchema, TChildEvents>, options?: {\n        id?: string;\n        autoForward?: boolean;\n        sync?: boolean;\n    }): Actor<State<TChildContext, TChildEvents>>;\n    private spawnPromise;\n    private spawnCallback;\n    private spawnObservable;\n    private spawnActivity;\n    private spawnEffect;\n    private reportUnhandledExceptionOnInvocation;\n    private attachDev;\n    toJSON(): {\n        id: string;\n    };\n}\nexport declare type Spawnable<TContext> = StateMachine<TContext, any, any> | Promise<TContext> | InvokeCallback | Subscribable<TContext>;\nexport declare function spawn<TContext>(entity: Spawnable<TContext>, nameOrOptions?: string | SpawnOptions): Actor<TContext>;\n/**\n * Creates a new Interpreter instance for the given machine with the provided options, if any.\n *\n * @param machine The machine to interpret\n * @param options Interpreter options\n */\nexport declare function interpret<TContext = DefaultContext, TStateSchema extends StateSchema = any, TEvent extends EventObject = EventObject>(machine: StateMachine<TContext, TStateSchema, TEvent>, options?: Partial<InterpreterOptions>): Interpreter<TContext, TStateSchema, TEvent>;\nexport {};\n"
  },
  {
    "fileName": "invoke.d.ts",
    "content": "export interface InvokedPromiseOptions {\n    id?: string;\n}\nexport interface PromiseMachineSchema {\n    states: {\n        pending: {};\n        resolved: {};\n        rejected: {};\n    };\n}\n"
  },
  {
    "fileName": "mapState.d.ts",
    "content": "export declare function mapState(stateMap: {\n    [stateId: string]: any;\n}, stateId: string): any;\n"
  },
  {
    "fileName": "match.d.ts",
    "content": "import { State } from './State';\nimport { StateValue, EventObject } from './types';\nexport declare type ValueFromStateGetter<T, TContext, TEvent extends EventObject> = (state: State<TContext, TEvent>) => T;\nexport declare type StatePatternTuple<T, TContext, TEvent extends EventObject> = [StateValue, ValueFromStateGetter<T, TContext, TEvent>];\nexport declare function matchState<T, TContext, TEvent extends EventObject>(state: State<TContext, TEvent> | StateValue, patterns: Array<StatePatternTuple<T, TContext, TEvent>>, defaultValue: ValueFromStateGetter<T, TContext, TEvent>): T;\n"
  },
  {
    "fileName": "patterns.d.ts",
    "content": "import { AtomicStateNodeConfig, StatesConfig, Event, EventObject, StateSchema } from './types';\nexport declare function toggle<TEventType extends string = string>(onState: string, offState: string, eventType: TEventType): Record<string, AtomicStateNodeConfig<any, {\n    type: TEventType;\n}>>;\ninterface SequencePatternOptions<TEvent extends EventObject> {\n    nextEvent: Event<TEvent> | undefined;\n    prevEvent: Event<TEvent> | undefined;\n}\nexport declare function sequence<TStateSchema extends StateSchema, TEvent extends EventObject>(items: string[], options?: Partial<SequencePatternOptions<TEvent>>): {\n    initial: keyof TStateSchema['states'];\n    states: StatesConfig<any, TStateSchema, TEvent>;\n};\nexport {};\n"
  },
  {
    "fileName": "scheduler.d.ts",
    "content": "interface SchedulerOptions {\n    deferEvents: boolean;\n}\nexport declare class Scheduler {\n    private processingEvent;\n    private queue;\n    private initialized;\n    private options;\n    constructor(options?: Partial<SchedulerOptions>);\n    initialize(callback?: () => void): void;\n    schedule(task: () => void): void;\n    private flushEvents;\n    private process;\n}\nexport {};\n"
  },
  {
    "fileName": "scxml.d.ts",
    "content": "import { EventObject } from './types';\nimport { StateNode } from './index';\nexport interface ScxmlToMachineOptions {\n    evalCond: (expr: string, extState?: object) => // tslint:disable-next-line:ban-types\n    ((extState: any, event: EventObject) => boolean) | Function;\n    delimiter?: string;\n}\nexport declare function toMachine(xml: string, options: ScxmlToMachineOptions): StateNode;\n"
  },
  {
    "fileName": "stateUtils.d.ts",
    "content": "import { EventObject, StateNode, StateValue } from '.';\ndeclare type Configuration<TC, TE extends EventObject> = Iterable<StateNode<TC, any, TE>>;\ndeclare type AdjList<TC, TE extends EventObject> = Map<StateNode<TC, any, TE>, Array<StateNode<TC, any, TE>>>;\nexport declare function getConfiguration<TC, TE extends EventObject>(prevStateNodes: Iterable<StateNode<TC, any, TE>>, stateNodes: Iterable<StateNode<TC, any, TE>>): Iterable<StateNode<TC, any, TE>>;\nexport declare function getAdjList<TC, TE extends EventObject>(configuration: Configuration<TC, TE>): AdjList<TC, TE>;\nexport declare function getValue<TC, TE extends EventObject>(rootNode: StateNode<TC, any, TE>, configuration: Configuration<TC, TE>): StateValue;\nexport {};\n"
  },
  {
    "fileName": "types.d.ts",
    "content": "import { StateNode } from './StateNode';\nimport { State } from './State';\nimport { StateTree } from './StateTree';\nimport { Interpreter, Clock } from './interpreter';\nimport { Actor } from './Actor';\nexport declare type EventType = string;\nexport declare type ActionType = string;\nexport declare type MetaObject = Record<string, any>;\n/**\n * The full definition of an event, with a string `type`.\n */\nexport interface EventObject {\n    /**\n     * The type of event that is sent.\n     */\n    type: string;\n    /**\n     * The unique ID that identifies this specific event instance.\n     */\n    id?: string | number;\n    [other: string]: any;\n}\n/**\n * The full definition of an action, with a string `type` and an\n * `exec` implementation function.\n */\nexport interface ActionObject<TContext, TEvent extends EventObject> {\n    /**\n     * The type of action that is executed.\n     */\n    type: string;\n    /**\n     * The implementation for executing the action.\n     */\n    exec?: ActionFunction<TContext, TEvent>;\n    [other: string]: any;\n}\nexport declare type DefaultContext = Record<string, any> | undefined;\n/**\n * The specified string event types or the specified event objects.\n */\nexport declare type Event<TEvent extends EventObject> = TEvent['type'] | TEvent;\n/**\n * Represents the specified event types or the full event objects,\n * as well as the built in event types and/or objects.\n */\nexport declare type OmniEvent<TEvent extends EventObject> = TEvent['type'] | BuiltInEvent<TEvent>['type'] | OmniEventObject<TEvent>;\nexport interface ActionMeta<TContext, TEvent extends EventObject> extends StateMeta<TContext, TEvent> {\n    action: ActionObject<TContext, TEvent>;\n}\nexport declare type ActionFunction<TContext, TEvent extends EventObject> = (context: TContext, event: TEvent, meta: ActionMeta<TContext, TEvent>) => any | void;\nexport declare type Action<TContext, TEvent extends EventObject> = ActionType | ActionObject<TContext, TEvent> | ActionFunction<TContext, TEvent>;\nexport declare type StateKey = string | State<any>;\nexport interface StateValueMap {\n    [key: string]: StateValue;\n}\n/**\n * The string or object representing the state value relative to the parent state node.\n *\n * - For a child atomic state node, this is a string, e.g., `\"pending\"`.\n * - For complex state nodes, this is an object, e.g., `{ success: \"someChildState\" }`.\n */\nexport declare type StateValue = string | StateValueMap;\nexport interface HistoryValue {\n    states: Record<string, HistoryValue | undefined>;\n    current: StateValue | undefined;\n}\nexport declare type ConditionPredicate<TContext, TEvent extends EventObject> = (context: TContext, event: TEvent, meta: GuardMeta<TContext, TEvent>) => boolean;\nexport declare type DefaultGuardType = 'xstate.guard';\nexport interface GuardPredicate<TContext, TEvent extends EventObject> {\n    type: DefaultGuardType;\n    name: string | undefined;\n    predicate: ConditionPredicate<TContext, OmniEventObject<TEvent>>;\n}\nexport declare type Guard<TContext, TEvent extends EventObject> = GuardPredicate<TContext, TEvent> | (Record<string, any> & {\n    type: string;\n});\nexport interface GuardMeta<TContext, TEvent extends EventObject> extends StateMeta<TContext, TEvent> {\n    cond: Guard<TContext, TEvent>;\n}\nexport declare type Condition<TContext, TEvent extends EventObject> = string | ConditionPredicate<TContext, TEvent> | Guard<TContext, TEvent>;\nexport declare type TransitionTarget<TContext> = SingleOrArray<string | StateNode<TContext, any>>;\nexport declare type TransitionTargets<TContext> = Array<string | StateNode<TContext, any>>;\nexport interface TransitionConfig<TContext, TEvent extends EventObject> {\n    cond?: Condition<TContext, TEvent>;\n    actions?: SingleOrArray<Action<TContext, TEvent>>;\n    in?: StateValue;\n    internal?: boolean;\n    target?: TransitionTarget<TContext>;\n    meta?: Record<string, any>;\n}\nexport interface TargetTransitionConfig<TContext, TEvent extends EventObject> extends TransitionConfig<TContext, TEvent> {\n    target: TransitionTarget<TContext>;\n}\nexport declare type ConditionalTransitionConfig<TContext, TEvent extends EventObject = EventObject> = Array<TransitionConfig<TContext, TEvent>>;\nexport declare type Transition<TContext, TEvent extends EventObject = EventObject> = string | TransitionConfig<TContext, TEvent> | ConditionalTransitionConfig<TContext, TEvent>;\nexport declare type DisposeActivityFunction = () => void;\nexport declare type ActivityConfig<TContext, TEvent extends EventObject> = (ctx: TContext, activity: ActivityDefinition<TContext, TEvent>) => DisposeActivityFunction | void;\nexport declare type Activity<TContext, TEvent extends EventObject> = string | ActivityDefinition<TContext, TEvent>;\nexport interface ActivityDefinition<TContext, TEvent extends EventObject> extends ActionObject<TContext, TEvent> {\n    id: string;\n    type: string;\n}\nexport declare type Sender<TEvent extends EventObject> = (event: Event<TEvent>) => void;\nexport declare type Receiver<TEvent extends EventObject> = (listener: (event: TEvent) => void) => void;\nexport declare type InvokeCallback = (sender: Sender<any>, onEvent: Receiver<EventObject>) => any;\n/**\n * Returns either a Promises or a callback handler (for streams of events) given the\n * machine's current `context` and `event` that invoked the service.\n *\n * For Promises, the only events emitted to the parent will be:\n * - `done.invoke.<id>` with the `data` containing the resolved payload when the promise resolves, or:\n * - `error.execution` with the `data` containing the caught error, and `src` containing the service `id`.\n *\n * For callback handlers, the `sender` will be provided, which will send events to the parent service.\n *\n * @param context The current machine `context`\n * @param event The event that invoked the service\n */\nexport declare type InvokeCreator<TContext, TFinalContext = any> = (context: TContext, event: EventObject) => PromiseLike<TFinalContext> | StateMachine<TFinalContext, any, any> | Subscribable<any> | InvokeCallback;\nexport interface InvokeDefinition<TContext, TEvent extends EventObject> extends ActivityDefinition<TContext, TEvent> {\n    /**\n     * The source of the machine to be invoked, or the machine itself.\n     */\n    src: string;\n    /**\n     * If `true`, events sent to the parent service will be forwarded to the invoked service.\n     *\n     * Default: `false`\n     */\n    autoForward?: boolean;\n    /**\n     * @deprecated\n     *\n     *  Use `autoForward` property instead of `forward`. Support for `forward` will get removed in the future.\n     */\n    forward?: boolean;\n    /**\n     * Data from the parent machine's context to set as the (partial or full) context\n     * for the invoked child machine.\n     *\n     * Data should be mapped to match the child machine's context shape.\n     */\n    data?: Mapper<TContext, TEvent> | PropertyMapper<TContext, TEvent>;\n}\nexport interface Delay {\n    id: string;\n    /**\n     * The time to delay the event, in milliseconds.\n     */\n    delay: number;\n}\nexport declare type DelayedTransitions<TContext, TEvent extends EventObject> = Record<string | number, string | SingleOrArray<TransitionConfig<TContext, TEvent>>> | Array<TransitionConfig<TContext, TEvent> & {\n    delay: number | string | Expr<TContext, TEvent, number>;\n}>;\nexport declare type StateTypes = 'atomic' | 'compound' | 'parallel' | 'final' | 'history' | string;\nexport declare type SingleOrArray<T> = T[] | T;\nexport declare type StateNodesConfig<TContext, TStateSchema extends StateSchema, TEvent extends EventObject> = {\n    [K in keyof TStateSchema['states']]: StateNode<TContext, TStateSchema['states'][K], TEvent>;\n};\nexport declare type StatesConfig<TContext, TStateSchema extends StateSchema, TEvent extends EventObject> = {\n    [K in keyof TStateSchema['states']]: StateNodeConfig<TContext, TStateSchema['states'][K], TEvent>;\n};\nexport declare type StatesDefinition<TContext, TStateSchema extends StateSchema, TEvent extends EventObject> = {\n    [K in keyof TStateSchema['states']]: StateNodeDefinition<TContext, TStateSchema['states'][K], TEvent>;\n};\nexport declare type TransitionsConfig<TContext, TEvent extends EventObject> = {\n    [K in TEvent['type'] | BuiltInEvent<TEvent>['type']]?: string | number | StateNode<TContext, any, TEvent> | SingleOrArray<TransitionConfig<TContext, TEvent extends {\n        type: K;\n    } ? TEvent : EventObject>>;\n};\nexport declare type TransitionsDefinition<TContext, TEvent extends EventObject> = {\n    [K in TEvent['type']]: Array<TransitionDefinition<TContext, Extract<TEvent, {\n        type: K;\n    }>>>;\n};\nexport declare type InvokeConfig<TContext, TEvent extends EventObject> = {\n    /**\n     * The unique identifier for the invoked machine. If not specified, this\n     * will be the machine's own `id`, or the URL (from `src`).\n     */\n    id?: string;\n    /**\n     * The source of the machine to be invoked, or the machine itself.\n     */\n    src: string | StateMachine<any, any, any> | InvokeCreator<any, any>;\n    /**\n     * If `true`, events sent to the parent service will be forwarded to the invoked service.\n     *\n     * Default: `false`\n     */\n    autoForward?: boolean;\n    /**\n     * @deprecated\n     *\n     *  Use `autoForward` property instead of `forward`. Support for `forward` will get removed in the future.\n     */\n    forward?: boolean;\n    /**\n     * Data from the parent machine's context to set as the (partial or full) context\n     * for the invoked child machine.\n     *\n     * Data should be mapped to match the child machine's context shape.\n     */\n    data?: Mapper<TContext, TEvent> | PropertyMapper<TContext, TEvent>;\n    /**\n     * The transition to take upon the invoked child machine reaching its final top-level state.\n     */\n    onDone?: string | SingleOrArray<TransitionConfig<TContext, DoneInvokeEvent<any>>>;\n    /**\n     * The transition to take upon the invoked child machine sending an error event.\n     */\n    onError?: string | SingleOrArray<TransitionConfig<TContext, DoneInvokeEvent<any>>>;\n} | StateMachine<any, any, any>;\nexport declare type InvokesConfig<TContext, TEvent extends EventObject> = SingleOrArray<InvokeConfig<TContext, TEvent>>;\nexport interface StateNodeConfig<TContext, TStateSchema extends StateSchema, TEvent extends EventObject> {\n    /**\n     * The relative key of the state node, which represents its location in the overall state value.\n     * This is automatically determined by the configuration shape via the key where it was defined.\n     */\n    key?: string;\n    /**\n     * The initial state node key.\n     */\n    initial?: keyof TStateSchema['states'] | undefined;\n    /**\n     * @deprecated\n     */\n    parallel?: boolean | undefined;\n    /**\n     * The type of this state node:\n     *\n     *  - `'atomic'` - no child state nodes\n     *  - `'compound'` - nested child state nodes (XOR)\n     *  - `'parallel'` - orthogonal nested child state nodes (AND)\n     *  - `'history'` - history state node\n     *  - `'final'` - final state node\n     */\n    type?: StateTypes;\n    /**\n     * The initial context (extended state) of the machine.\n     */\n    context?: TContext;\n    /**\n     * Indicates whether the state node is a history state node, and what\n     * type of history:\n     * shallow, deep, true (shallow), false (none), undefined (none)\n     */\n    history?: 'shallow' | 'deep' | boolean | undefined;\n    /**\n     * The mapping of state node keys to their state node configurations (recursive).\n     */\n    states?: StatesConfig<TContext, TStateSchema, TEvent> | undefined;\n    /**\n     * The services to invoke upon entering this state node. These services will be stopped upon exiting this state node.\n     */\n    invoke?: InvokesConfig<TContext, TEvent>;\n    /**\n     * The mapping of event types to their potential transition(s).\n     */\n    on?: TransitionsConfig<TContext, TEvent>;\n    /**\n     * The action(s) to be executed upon entering the state node.\n     *\n     * @deprecated Use `entry` instead.\n     */\n    onEntry?: SingleOrArray<Action<TContext, TEvent>>;\n    /**\n     * The action(s) to be executed upon entering the state node.\n     */\n    entry?: SingleOrArray<Action<TContext, TEvent>>;\n    /**\n     * The action(s) to be executed upon exiting the state node.\n     *\n     * @deprecated Use `exit` instead.\n     */\n    onExit?: SingleOrArray<Action<TContext, TEvent>>;\n    /**\n     * The action(s) to be executed upon exiting the state node.\n     */\n    exit?: SingleOrArray<Action<TContext, TEvent>>;\n    /**\n     * The potential transition(s) to be taken upon reaching a final child state node.\n     *\n     * This is equivalent to defining a `[done(id)]` transition on this state node's `on` property.\n     */\n    onDone?: string | SingleOrArray<TransitionConfig<TContext, DoneEventObject>>;\n    /**\n     * The mapping (or array) of delays (in milliseconds) to their potential transition(s).\n     * The delayed transitions are taken after the specified delay in an interpreter.\n     */\n    after?: DelayedTransitions<TContext, TEvent>;\n    /**\n     * The activities to be started upon entering the state node,\n     * and stopped upon exiting the state node.\n     */\n    activities?: SingleOrArray<Activity<TContext, TEvent>>;\n    /**\n     * @private\n     */\n    parent?: StateNode<TContext, any, TEvent>;\n    strict?: boolean | undefined;\n    /**\n     * The meta data associated with this state node, which will be returned in State instances.\n     */\n    meta?: TStateSchema extends {\n        meta: infer D;\n    } ? D : any;\n    /**\n     * The data sent with the \"done.state._id_\" event if this is a final state node.\n     *\n     * The data will be evaluated with the current `context` and placed on the `.data` property\n     * of the event.\n     */\n    data?: Mapper<TContext, TEvent> | PropertyMapper<TContext, TEvent>;\n    /**\n     * The unique ID of the state node, which can be referenced as a transition target via the\n     * `#id` syntax.\n     */\n    id?: string | undefined;\n    /**\n     * The string delimiter for serializing the path to a string. The default is \".\"\n     */\n    delimiter?: string;\n    /**\n     * The order this state node appears. Corresponds to the implicit SCXML document order.\n     */\n    order?: number;\n}\nexport interface StateNodeDefinition<TContext, TStateSchema extends StateSchema, TEvent extends EventObject> extends StateNodeConfig<TContext, TStateSchema, TEvent> {\n    id: string;\n    version: string | undefined;\n    key: string;\n    type: StateTypes;\n    initial: StateNodeConfig<TContext, TStateSchema, TEvent>['initial'];\n    history: boolean | 'shallow' | 'deep' | undefined;\n    states: StatesDefinition<TContext, TStateSchema, TEvent>;\n    on: TransitionsDefinition<TContext, TEvent>;\n    onEntry: Array<ActionObject<TContext, TEvent>>;\n    onExit: Array<ActionObject<TContext, TEvent>>;\n    activities: Array<ActivityDefinition<TContext, TEvent>>;\n    meta: any;\n    order: number;\n    data?: FinalStateNodeConfig<TContext, TEvent>['data'];\n    invoke: Array<InvokeDefinition<TContext, TEvent>>;\n}\nexport declare type AnyStateNodeDefinition = StateNodeDefinition<any, any, any>;\nexport interface AtomicStateNodeConfig<TContext, TEvent extends EventObject> extends StateNodeConfig<TContext, StateSchema, TEvent> {\n    initial?: undefined;\n    parallel?: false | undefined;\n    states?: undefined;\n    onDone?: undefined;\n}\nexport interface HistoryStateNodeConfig<TContext, TEvent extends EventObject> extends AtomicStateNodeConfig<TContext, TEvent> {\n    history: 'shallow' | 'deep' | true;\n    target: StateValue | undefined;\n}\nexport interface FinalStateNodeConfig<TContext, TEvent extends EventObject> extends AtomicStateNodeConfig<TContext, TEvent> {\n    type: 'final';\n    /**\n     * The data to be sent with the \"done.state.<id>\" event. The data can be\n     * static or dynamic (based on assigners).\n     */\n    data?: Assigner<TContext, TEvent> | PropertyAssigner<TContext, TEvent> | any;\n}\nexport interface CompoundStateNodeConfig<TContext, TStateSchema extends StateSchema, TEvent extends EventObject> extends StateNodeConfig<TContext, TStateSchema, TEvent> {\n    parallel?: boolean;\n    states: StateNodeConfig<TContext, TStateSchema, TEvent>['states'];\n}\nexport declare type SimpleOrCompoundStateNodeConfig<TContext, TStateSchema extends StateSchema, TEvent extends EventObject> = AtomicStateNodeConfig<TContext, TEvent> | CompoundStateNodeConfig<TContext, TStateSchema, TEvent>;\nexport declare type ActionFunctionMap<TContext, TEvent extends EventObject> = Record<string, ActionObject<TContext, TEvent> | ActionFunction<TContext, TEvent>>;\nexport declare type ServiceConfig<TContext> = string | StateMachine<any, any, any> | InvokeCreator<TContext>;\nexport declare type DelayConfig<TContext, TEvent extends EventObject> = number | Expr<TContext, OmniEventObject<TEvent>, number>;\nexport interface MachineOptions<TContext, TEvent extends EventObject> {\n    guards: Record<string, ConditionPredicate<TContext, TEvent>>;\n    actions: ActionFunctionMap<TContext, TEvent>;\n    activities: Record<string, ActivityConfig<TContext, TEvent>>;\n    services: Record<string, ServiceConfig<TContext>>;\n    delays: Record<string, DelayConfig<TContext, TEvent>>;\n    updater: Updater<TContext, TEvent>;\n}\nexport interface MachineConfig<TContext, TStateSchema extends StateSchema, TEvent extends EventObject> extends CompoundStateNodeConfig<TContext, TStateSchema, TEvent> {\n    /**\n     * The initial context (extended state)\n     */\n    context?: TContext;\n    /**\n     * The machine's own version.\n     */\n    version?: string;\n}\nexport interface StandardMachineConfig<TContext, TStateSchema extends StateSchema, TEvent extends EventObject> extends CompoundStateNodeConfig<TContext, TStateSchema, TEvent> {\n}\nexport interface ParallelMachineConfig<TContext, TStateSchema extends StateSchema, TEvent extends EventObject> extends CompoundStateNodeConfig<TContext, TStateSchema, TEvent> {\n    initial?: undefined;\n    type?: 'parallel';\n}\nexport interface EntryExitEffectMap<TContext, TEvent extends EventObject> {\n    entry: Array<ActionObject<TContext, TEvent>>;\n    exit: Array<ActionObject<TContext, TEvent>>;\n}\nexport interface HistoryStateNode<TContext> extends StateNode<TContext> {\n    history: 'shallow' | 'deep';\n    target: StateValue | undefined;\n}\nexport interface StateMachine<TContext, TStateSchema extends StateSchema, TEvent extends EventObject> extends StateNode<TContext, TStateSchema, TEvent> {\n    id: string;\n    states: StateNode<TContext, TStateSchema, TEvent>['states'];\n}\nexport interface ActionMap<TContext, TEvent extends EventObject> {\n    onEntry: Array<Action<TContext, TEvent>>;\n    actions: Array<Action<TContext, TEvent>>;\n    onExit: Array<Action<TContext, TEvent>>;\n}\nexport interface EntryExitStates<TContext> {\n    entry: Set<StateNode<TContext>>;\n    exit: Set<StateNode<TContext>>;\n}\nexport interface EntryExitStateArrays<TContext> {\n    entry: Array<StateNode<TContext>>;\n    exit: Array<StateNode<TContext>>;\n}\nexport interface ActivityMap {\n    [activityKey: string]: ActivityDefinition<any, any> | false;\n}\nexport interface StateTransition<TContext, TEvent extends EventObject> {\n    tree: StateTree | undefined;\n    transitions: Array<TransitionDefinition<TContext, TEvent>>;\n    configuration: Array<StateNode<TContext, any, TEvent>>;\n    /**\n     * The source state that preceded the transition.\n     */\n    source: State<TContext> | undefined;\n    context?: TContext;\n    actions: Array<ActionObject<TContext, TEvent>>;\n}\nexport interface TransitionData<TContext, TEvent extends EventObject> {\n    value: StateValue | undefined;\n    actions: ActionMap<TContext, TEvent>;\n    activities?: ActivityMap;\n}\nexport declare enum ActionTypes {\n    Start = \"xstate.start\",\n    Stop = \"xstate.stop\",\n    Raise = \"xstate.raise\",\n    Send = \"xstate.send\",\n    Cancel = \"xstate.cancel\",\n    NullEvent = \"\",\n    Assign = \"xstate.assign\",\n    After = \"xstate.after\",\n    DoneState = \"done.state\",\n    DoneInvoke = \"done.invoke\",\n    Log = \"xstate.log\",\n    Init = \"xstate.init\",\n    Invoke = \"xstate.invoke\",\n    ErrorExecution = \"error.execution\",\n    ErrorCommunication = \"error.communication\",\n    ErrorPlatform = \"error.platform\",\n    Update = \"xstate.update\",\n    Pure = \"xstate.pure\"\n}\nexport interface RaisedEvent<TEvent extends EventObject> {\n    type: ActionTypes.Raise;\n    event: TEvent;\n}\nexport interface RaiseEvent<TContext, TEvent extends EventObject> extends ActionObject<TContext, TEvent> {\n    event: Event<TEvent>;\n}\nexport interface DoneInvokeEvent<TData> extends EventObject {\n    data: TData;\n}\nexport interface ErrorExecutionEvent extends EventObject {\n    src: string;\n    type: ActionTypes.ErrorExecution;\n    data: any;\n}\nexport interface ErrorPlatformEvent extends EventObject {\n    data: any;\n}\nexport interface DoneEventObject extends EventObject {\n    data?: any;\n    toString(): string;\n}\nexport interface UpdateObject extends EventObject {\n    id: string | number;\n    state: State<any, any>;\n}\nexport declare type DoneEvent = DoneEventObject & string;\nexport declare type BuiltInEvent<TEvent extends EventObject> = {\n    type: ActionTypes.NullEvent;\n} | {\n    type: ActionTypes.Init;\n} | RaisedEvent<TEvent> | ErrorExecutionEvent;\n/**\n * Represents the specified events and the built-in internal events.\n */\nexport declare type OmniEventObject<TEvent extends EventObject> = TEvent | BuiltInEvent<TEvent>;\nexport interface ActivityActionObject<TContext, TEvent extends EventObject> extends ActionObject<TContext, TEvent> {\n    type: ActionTypes.Start | ActionTypes.Stop;\n    activity: ActivityDefinition<TContext, TEvent>;\n    exec: ActionFunction<TContext, TEvent> | undefined;\n}\nexport interface SendAction<TContext, TEvent extends EventObject> extends ActionObject<TContext, TEvent> {\n    to: string | number | Actor | Expr<TContext, TEvent, string | number | Actor> | undefined;\n    event: TEvent | SendExpr<TContext, TEvent>;\n    delay?: number | string | Expr<TContext, TEvent, number>;\n    id: string | number;\n}\nexport interface SendActionObject<TContext, TEvent extends EventObject> extends SendAction<TContext, TEvent> {\n    to: string | number | Actor | undefined;\n    event: TEvent;\n    delay?: number | string;\n    id: string | number;\n}\nexport declare type Expr<TContext, TEvent extends EventObject, T> = (context: TContext, event: TEvent) => T;\nexport declare type SendExpr<TContext, TEvent extends EventObject> = (context: TContext, event: TEvent) => OmniEvent<TEvent>;\nexport declare enum SpecialTargets {\n    Parent = \"#_parent\",\n    Internal = \"#_internal\"\n}\nexport interface SendActionOptions<TContext, TEvent extends EventObject> {\n    id?: string | number;\n    delay?: number | string | Expr<TContext, TEvent, number>;\n    to?: string | Expr<TContext, TEvent, string | number | Actor>;\n}\nexport interface CancelAction extends ActionObject<any, any> {\n    sendId: string | number;\n}\nexport declare type Assigner<TContext, TEvent extends EventObject> = (context: TContext, event: TEvent) => Partial<TContext>;\nexport declare type PropertyAssigner<TContext, TEvent extends EventObject> = Partial<{\n    [K in keyof TContext]: ((context: TContext, event: TEvent) => TContext[K]) | TContext[K];\n}>;\nexport declare type Mapper<TContext, TEvent extends EventObject> = (context: TContext, event: TEvent) => any;\nexport declare type PropertyMapper<TContext, TEvent extends EventObject> = Partial<{\n    [key: string]: ((context: TContext, event: TEvent) => any) | any;\n}>;\nexport declare type Updater<TContext, TEvent extends EventObject, TAssignAction extends AnyAssignAction<TContext, TEvent> = AnyAssignAction<TContext, TEvent>> = (context: TContext, event: OmniEventObject<TEvent>, assignActions: TAssignAction[]) => TContext;\nexport interface AnyAssignAction<TContext, TEvent extends EventObject> extends ActionObject<TContext, TEvent> {\n    type: ActionTypes.Assign;\n    assignment: any;\n}\nexport interface AssignAction<TContext, TEvent extends EventObject> extends ActionObject<TContext, TEvent> {\n    type: ActionTypes.Assign;\n    assignment: Assigner<TContext, TEvent> | PropertyAssigner<TContext, TEvent>;\n}\nexport interface PureAction<TContext, TEvent extends EventObject> extends ActionObject<TContext, TEvent> {\n    type: ActionTypes.Pure;\n    get: (context: TContext, event: OmniEventObject<TEvent>) => SingleOrArray<ActionObject<TContext, TEvent>> | undefined;\n}\nexport interface TransitionDefinition<TContext, TEvent extends EventObject> extends TransitionConfig<TContext, TEvent> {\n    target: TransitionTargets<TContext> | undefined;\n    source: StateNode<TContext, any, TEvent>;\n    actions: Array<ActionObject<TContext, TEvent>>;\n    cond?: Guard<TContext, TEvent>;\n    event: string;\n}\nexport interface DelayedTransitionDefinition<TContext, TEvent extends EventObject> extends TransitionDefinition<TContext, TEvent> {\n    delay: number | string | Expr<TContext, TEvent, number>;\n}\nexport interface Edge<TContext, TEvent extends EventObject, TEventType extends TEvent['type'] = string> {\n    event: TEventType;\n    source: StateNode<TContext, any, TEvent>;\n    target: StateNode<TContext, any, TEvent>;\n    cond?: Condition<TContext, TEvent & {\n        type: TEventType;\n    }>;\n    actions: Array<Action<TContext, TEvent>>;\n    meta?: MetaObject;\n    transition: TransitionDefinition<TContext, OmniEventObject<TEvent>>;\n}\nexport interface NodesAndEdges<TContext, TEvent extends EventObject> {\n    nodes: StateNode[];\n    edges: Array<Edge<TContext, TEvent, TEvent['type']>>;\n}\nexport interface Segment<TContext, TEvent extends EventObject> {\n    /**\n     * From state.\n     */\n    state: State<TContext, TEvent>;\n    /**\n     * Event from state.\n     */\n    event: TEvent;\n}\nexport interface PathItem<TContext, TEvent extends EventObject> {\n    state: State<TContext, TEvent>;\n    path: Array<Segment<TContext, TEvent>>;\n    weight?: number;\n}\nexport interface PathMap<TContext, TEvent extends EventObject> {\n    [key: string]: PathItem<TContext, TEvent>;\n}\nexport interface PathsItem<TContext, TEvent extends EventObject> {\n    state: State<TContext, TEvent>;\n    paths: Array<Array<Segment<TContext, TEvent>>>;\n}\nexport interface PathsMap<TContext, TEvent extends EventObject> {\n    [key: string]: PathsItem<TContext, TEvent>;\n}\nexport interface TransitionMap {\n    state: StateValue | undefined;\n}\nexport interface AdjacencyMap {\n    [stateId: string]: Record<string, TransitionMap>;\n}\nexport interface ValueAdjacencyMap<TContext, TEvent extends EventObject> {\n    [stateId: string]: Record<string, State<TContext, TEvent>>;\n}\nexport interface StateMeta<TContext, TEvent extends EventObject> {\n    state: State<TContext, TEvent>;\n}\nexport interface StateInterface<TContext = DefaultContext, TEvent extends EventObject = EventObject> {\n    value: StateValue;\n    tree?: StateTree;\n    history?: State<TContext>;\n    historyValue?: HistoryValue | undefined;\n    actions: Array<ActionObject<TContext, TEvent>>;\n    activities: ActivityMap;\n    meta: any;\n    event: OmniEventObject<TEvent>;\n    events: TEvent[];\n    context: TContext;\n    toStrings: () => string[];\n    changed: boolean | undefined;\n    inert: any;\n    matches: (parentStateValue: StateValue) => boolean;\n    nextEvents: EventType[];\n}\nexport interface StateConfig<TContext, TEvent extends EventObject> {\n    value: StateValue;\n    context: TContext;\n    event: OmniEventObject<TEvent>;\n    historyValue?: HistoryValue | undefined;\n    history?: State<TContext>;\n    actions?: Array<ActionObject<TContext, TEvent>>;\n    activities?: ActivityMap;\n    meta?: any;\n    events?: TEvent[];\n    tree?: StateTree;\n}\nexport interface StateSchema {\n    meta?: any;\n    states?: Record<string | number, StateSchema>;\n}\nexport interface InterpreterOptions {\n    /**\n     * Whether state actions should be executed immediately upon transition. Defaults to `true`.\n     */\n    execute: boolean;\n    clock: Clock;\n    logger: (...args: any[]) => void;\n    parent?: Interpreter<any, any, any>;\n    /**\n     * If `true`, defers processing of sent events until the service\n     * is initialized (`.start()`). Otherwise, an error will be thrown\n     * for events sent to an uninitialized service.\n     *\n     * Default: `true`\n     */\n    deferEvents: boolean;\n    /**\n     * The custom `id` for referencing this service.\n     */\n    id?: string;\n    /**\n     * If `true`, states and events will be logged to Redux DevTools.\n     *\n     * Default: `false`\n     */\n    devTools: boolean | object;\n    [option: string]: any;\n}\nexport declare namespace SCXML {\n    interface Event {\n        /**\n         * This is a character string giving the name of the event.\n         * The SCXML Processor must set the name field to the name of this event.\n         * It is what is matched against the 'event' attribute of <transition>.\n         * Note that transitions can do additional tests by using the value of this field\n         * inside boolean expressions in the 'cond' attribute.\n         */\n        name: string;\n        /**\n         * This field describes the event type.\n         * The SCXML Processor must set it to: \"platform\" (for events raised by the platform itself, such as error events),\n         * \"internal\" (for events raised by <raise> and <send> with target '_internal')\n         * or \"external\" (for all other events).\n         */\n        type: 'platform' | 'internal' | 'external';\n        /**\n         * If the sending entity has specified a value for this, the Processor must set this field to that value\n         * (see C Event I/O Processors for details).\n         * Otherwise, in the case of error events triggered by a failed attempt to send an event,\n         * the Processor must set this field to the send id of the triggering <send> element.\n         * Otherwise it must leave it blank.\n         */\n        sendid: string | undefined;\n        /**\n         * This is a URI, equivalent to the 'target' attribute on the <send> element.\n         * For external events, the SCXML Processor should set this field to a value which,\n         * when used as the value of 'target', will allow the receiver of the event to <send>\n         * a response back to the originating entity via the Event I/O Processor specified in 'origintype'.\n         * For internal and platform events, the Processor must leave this field blank.\n         */\n        origin: string | undefined;\n        /**\n         * This is equivalent to the 'type' field on the <send> element.\n         * For external events, the SCXML Processor should set this field to a value which,\n         * when used as the value of 'type', will allow the receiver of the event to <send>\n         * a response back to the originating entity at the URI specified by 'origin'.\n         * For internal and platform events, the Processor must leave this field blank.\n         */\n        origintype: string | undefined;\n        /**\n         * If this event is generated from an invoked child process, the SCXML Processor\n         * must set this field to the invoke id of the invocation that triggered the child process.\n         * Otherwise it must leave it blank.\n         */\n        invokeid: string | undefined;\n        /**\n         * This field contains whatever data the sending entity chose to include in this event.\n         * The receiving SCXML Processor should reformat this data to match its data model,\n         * but must not otherwise modify it.\n         *\n         * If the conversion is not possible, the Processor must leave the field blank\n         * and must place an error 'error.execution' in the internal event queue.\n         */\n        data: Record<string, any> | undefined;\n        /**\n         * @private\n         */\n        $$type: 'scxml';\n    }\n}\nexport interface Unsubscribable {\n    unsubscribe(): any | void;\n}\nexport interface Subscribable<T> {\n    subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Unsubscribable;\n}\n"
  },
  {
    "fileName": "utils.d.ts",
    "content": "import { Event, StateValue, ActionType, Action, EventObject, StateInterface, PropertyMapper, Mapper, EventType, HistoryValue, OmniEventObject, AssignAction, ActionObject, Condition, Guard, Subscribable, StateMachine, ConditionPredicate } from './types';\nexport declare function keys<T extends object>(value: T): Array<keyof T & string>;\nexport declare function matchesState(parentStateId: StateValue, childStateId: StateValue, delimiter?: string): boolean;\nexport declare function getEventType<TEvent extends EventObject = EventObject>(event: Event<TEvent>): TEvent['type'];\nexport declare function getActionType(action: Action<any, any>): ActionType;\nexport declare function toStatePath(stateId: string | string[], delimiter: string): string[];\nexport declare function toStateValue(stateValue: StateInterface<any> | StateValue | string[], delimiter: string): StateValue;\nexport declare function pathToStateValue(statePath: string[]): StateValue;\nexport declare function mapValues<T, P>(collection: {\n    [key: string]: T;\n}, iteratee: (item: T, key: string, collection: {\n    [key: string]: T;\n}, i: number) => P): {\n    [key: string]: P;\n};\nexport declare function mapFilterValues<T, P>(collection: {\n    [key: string]: T;\n}, iteratee: (item: T, key: string, collection: {\n    [key: string]: T;\n}) => P, predicate: (item: T) => boolean): {\n    [key: string]: P;\n};\n/**\n * Retrieves a value at the given path.\n * @param props The deep path to the prop of the desired value\n */\nexport declare const path: <T extends Record<string, any>>(props: string[]) => any;\n/**\n * Retrieves a value at the given path via the nested accessor prop.\n * @param props The deep path to the prop of the desired value\n */\nexport declare function nestedPath<T extends Record<string, any>>(props: string[], accessorProp: keyof T): (object: T) => T;\nexport declare function toStatePaths(stateValue: StateValue | undefined): string[][];\nexport declare const pathsToStateValue: (paths: string[][]) => StateValue;\nexport declare function flatten<T>(array: Array<T | T[]>): T[];\nexport declare function toArray<T>(value: T[] | T | undefined): T[];\nexport declare function mapContext<TContext, TEvent extends EventObject>(mapper: Mapper<TContext, TEvent> | PropertyMapper<TContext, TEvent>, context: TContext, event: TEvent): any;\nexport declare function isBuiltInEvent(eventType: EventType): boolean;\nexport declare function isPromiseLike(value: any): value is PromiseLike<any>;\nexport declare function partition<T, A extends T, B extends T>(items: T[], predicate: (item: T) => item is A): [A[], B[]];\nexport declare function updateHistoryStates(hist: HistoryValue, stateValue: StateValue): Record<string, HistoryValue | undefined>;\nexport declare function updateHistoryValue(hist: HistoryValue, stateValue: StateValue): HistoryValue;\nexport declare function updateContext<TContext, TEvent extends EventObject>(context: TContext, event: OmniEventObject<TEvent>, assignActions: Array<AssignAction<TContext, TEvent>>): TContext;\nexport declare function bindActionToState<TC, TE extends EventObject>(action: ActionObject<TC, TE>, state: StateInterface<TC, TE>): ActionObject<TC, TE>;\ndeclare let warn: (condition: boolean | Error, message: string) => void;\nexport { warn };\nexport declare function isArray(value: any): value is any[];\nexport declare function isFunction(value: any): value is Function;\nexport declare function isString(value: any): value is string;\nexport declare function toGuard<TContext, TEvent extends EventObject>(condition?: Condition<TContext, TEvent>, guardMap?: Record<string, ConditionPredicate<TContext, TEvent>>): Guard<TContext, TEvent> | undefined;\nexport declare function isObservable<T>(value: Subscribable<T> | any): value is Subscribable<T>;\nexport declare function isMachine(value: any): value is StateMachine<any, any, any>;\nexport declare const uniqueId: () => string;\n"
  }
]
